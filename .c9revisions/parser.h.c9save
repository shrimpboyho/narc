{"ts":1374772958281,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1374772976411,"patch":[[{"diffs":[[1,"///\n/// @file   ExpressionParser.h\n/// @brief  Simple C++ operator precedence parser with infix notation\n///         for integer arithmetic expressions.\n/// @see    http://expressionparser.googlecode.com\n///\n/// Copyright (C) 2013 Kim Walisch, <kim.walisch@gmail.com>\n///\n/// This file is distributed under the New BSD License. See the\n/// LICENSE file in the top level directory.\n///\n\n#ifndef PARSER_H\n#define PARSER_H\n\n#include <stdexcept>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <cstddef>\n#include <cctype>\n\n/// ExpressionParser throws a parser_error if it fails\n/// to evaluate the expression string.\n///\nclass parser_error : public std::runtime_error {\npublic:\n  parser_error(const std::string& expr, const std::string& message)\n    : std::runtime_error(message),\n      expr_(expr)\n  { }\n  ~parser_error() throw() { }\n  std::string expression() const {\n    return expr_;\n  }\nprivate:\n  std::string expr_;\n};\n\n/// @class   ExpressionParser<T>\n/// @brief   ExpressionParser is a simple C++ operator precedence\n///          parser with infix notation for integer arithmetic\n///          expressions. Its `T eval(const std::string&)' method\n///          evaluates an arithmetic expression and returns the result.\n///          Have a look at the homepage for a usage example.\n/// @author  Kim Walisch, <kim.walisch@gmail.com>\n/// @version 2.5\n/// @license New BSD License\n/// @date    February 15, 2013\n///\n/// == Supported operators ==\n///\n/// OPERATOR    NAME                     ASSOCIATIVITY    PRECEDENCE\n///\n/// |           Bitwise Inclusive OR    Left               4\n/// ^           Bitwise Exclusive OR    Left               5\n/// &           Bitwise AND             Left               6\n/// <<          Shift Left              Left               9\n/// >>          Shift Right             Left               9\n/// +           Addition                Left              10\n/// -           Subtraction             Left              10\n/// *           Multiplication          Left              20\n/// /           Division                Left              20\n/// %           Modulo                  Left              20\n/// **          Raise to power          Right             30\n/// e, E        Scientific notation     Right             40\n/// ~           Unary complement        Left              99\n///\n/// The operator precedence has been set according to (uses the C and\n/// C++ operator precedence): http://en.wikipedia.org/wiki/Order_of_operations\n/// Operators with higher precedence are evaluated before operators\n/// with relatively lower precedence. Unary operators are set to have\n/// the highest precedence, this is not strictly correct for the power\n/// operator e.g. \"-3**2\" = 9 but a lot of software tools (Bash shell,\n/// Microsoft Excel, GNU bc, ...) use the same convention.\n///\n/// == Examples of valid expressions ==\n///\n/// \"65536 >> 15\"                       = 2\n/// \"2**16\"                             = 65536\n/// \"(0 + 0xDf234 - 1000)*3/2%999\"      = 828\n/// \"-(2**2**2**2)\"                     = -65536\n/// \"(0 + ~(0xDF234 & 1000) *3) /-2\"    = 817\n/// \"(2**16) + (1 << 16) >> 0X5\"        = 4096\n/// \"5*-(2**(9+7))/3+5*(1 & 0xFf123)\"   = -109221\n///\n/// == About the algorithm used ==\n///\n/// ExpressionParser has its roots in a JavaScript parser published at:\n/// http://stackoverflow.com/questions/28256/equation-expression-parser-with-precedence/114961#114961\n/// The same author has also published an article about his operator\n/// precedence algorithm at PerlMonks:\n/// http://www.perlmonks.org/?node_id=554516\n///\ntemplate <typename T = int>\nclass ExpressionParser {\npublic:\n  /// Evaluate an integer arithmetic expression and return its result.\n  /// @throw parser_error if parsing fails.\n  ///\n  T eval(const std::string& expr) {\n    T result = 0;\n    index_ = 0;\n    expr_ = expr;\n    try {\n      result = parseExpr();\n      if (!isEnd())\n        unexpected();\n    }\n    catch (parser_error&) {\n      while(!stack_.empty()) stack_.pop();\n      throw;\n    }\n    return result;\n  }\n\n  /// Get the integer value of a character.\n  T eval(char c) {\n    std::string expr(1, c);\n    return eval(expr);\n  }\n\nprivate:\n  enum {\n    OPERATOR_NULL,\n    OPERATOR_BITWISE_OR,     /// |\n    OPERATOR_BITWISE_XOR,    /// ^\n    OPERATOR_BITWISE_AND,    /// &\n    OPERATOR_BITWISE_SHL,    /// <<\n    OPERATOR_BITWISE_SHR,    /// >>\n    OPERATOR_ADDITION,       /// +\n    OPERATOR_SUBTRACTION,    /// -\n    OPERATOR_MULTIPLICATION, /// *\n    OPERATOR_DIVISION,       /// /\n    OPERATOR_MODULO,         /// %\n    OPERATOR_POWER,          /// **\n    OPERATOR_EXPONENT        /// e, E\n  };\n\n  struct Operator {\n    /// Operator, one of the OPERATOR_* enum definitions\n    int op;\n    int precedence;\n    /// 'L' = left or 'R' = right\n    int associativity;\n    Operator(int opr, int precedence, int associativity) :\n      op(opr),\n      precedence(precedence),\n      associativity(associativity)\n    { }\n  };\n\n  struct OperatorValue {\n    Operator op;\n    T value;\n    OperatorValue(const Operator& opr, T value) :\n      op(opr),\n      value(value)\n    { }\n    int getPrecedence() const {\n      return op.precedence;\n    }\n    bool isNull() const {\n      return op.op == OPERATOR_NULL;\n    }\n  };\n\n  /// Expression string\n  std::string expr_;\n  /// Current expression index, incremented whilst parsing\n  std::size_t index_;\n  /// The current operator and its left value\n  /// are pushed onto the stack if the operator on\n  /// top of the stack has lower precedence.\n  std::stack<OperatorValue> stack_;\n\n  /// Exponentiation by squaring, x^n.\n  static T pow(T x, T n) {\n    T result = 1;\n    while (n != 0) {\n      if ((n & 1) != 0) {\n        result *= x;\n        n -= 1;\n      }\n      x *= x;\n      n /= 2;\n    }\n    return result;\n  }\n\n  T checkZero(T value) const {\n    if (value == 0) {\n      std::string divOperators(\"/%\");\n      std::size_t division = expr_.find_last_of(divOperators, index_ - 2);\n      std::ostringstream error;\n      error << \"Parser error: division by 0\";\n      if (division != std::string::npos)\n        error << \" (error token is \\\"\"\n              << expr_.substr(division, expr_.size() - division)\n              << \"\\\")\";\n      throw parser_error(expr_, error.str());\n    }\n    return value;\n  }\n\n  /// Atomic calculation with two operands and a given operator.\n  /// @return Result (int, long, ...) of the calculation.\n  ///\n  T calculate(T v1, T v2, const Operator& op) const {\n    switch (op.op) {\n      case OPERATOR_BITWISE_OR:     return v1 | v2;\n      case OPERATOR_BITWISE_XOR:    return v1 ^ v2;\n      case OPERATOR_BITWISE_AND:    return v1 & v2;\n      case OPERATOR_BITWISE_SHL:    return v1 << v2;\n      case OPERATOR_BITWISE_SHR:    return v1 >> v2;\n      case OPERATOR_ADDITION:       return v1 + v2;\n      case OPERATOR_SUBTRACTION:    return v1 - v2;\n      case OPERATOR_MULTIPLICATION: return v1 * v2;\n      case OPERATOR_DIVISION:       return v1 / checkZero(v2);\n      case OPERATOR_MODULO:         return v1 % checkZero(v2);\n      case OPERATOR_POWER:          return pow(v1, v2);\n      case OPERATOR_EXPONENT:       return v1 * pow(10, v2);\n      default:                      return 0;\n    }\n  }\n\n  bool isEnd() const {\n    return index_ >= expr_.size();\n  }\n\n  /// Returns the character at the current expression index or\n  /// 0 if the end of the expression is reached.\n  ///\n  char getCharacter() const {\n    if (!isEnd())\n      return expr_[index_];\n    return 0;\n  }\n\n  /// Parse str at the current expression index.\n  /// @throw parser_error if parsing fails.\n  ///\n  void expect(const std::string& str) {\n    if (expr_.compare(index_, str.size(), str) != 0)\n      unexpected();\n    index_ += str.size();\n  }\n\n  void unexpected() const {\n    std::ostringstream error;\n    error << \"Syntax error: unexpected token \\\"\"\n          << expr_.substr(index_, expr_.size() - index_)\n          << \"\\\" at index \"\n          << index_;\n    throw parser_error(expr_, error.str());\n  }\n\n  /// Eat all white space characters at the current expression index.\n  void eatSpaces() {\n    while (std::isspace(getCharacter()) != 0)\n      index_++;\n  }\n\n  /// Parse a binary operator at the current expression index.\n  /// @return Operator with precedence and associativity.\n  ///\n  Operator parseOp() {\n    eatSpaces();\n    switch (getCharacter()) {\n      case '|': index_++;     return Operator(OPERATOR_BITWISE_OR,      4, 'L');\n      case '^': index_++;     return Operator(OPERATOR_BITWISE_XOR,     5, 'L');\n      case '&': index_++;     return Operator(OPERATOR_BITWISE_AND,     6, 'L');\n      case '<': expect(\"<<\"); return Operator(OPERATOR_BITWISE_SHL,     9, 'L');\n      case '>': expect(\">>\"); return Operator(OPERATOR_BITWISE_SHR,     9, 'L');\n      case '+': index_++;     return Operator(OPERATOR_ADDITION,       10, 'L');\n      case '-': index_++;     return Operator(OPERATOR_SUBTRACTION,    10, 'L');\n      case '/': index_++;     return Operator(OPERATOR_DIVISION,       20, 'L');\n      case '%': index_++;     return Operator(OPERATOR_MODULO,         20, 'L');\n      case '*': index_++; if (getCharacter() != '*')\n                              return Operator(OPERATOR_MULTIPLICATION, 20, 'L');\n                index_++;     return Operator(OPERATOR_POWER,          30, 'R');\n      case 'e': index_++;     return Operator(OPERATOR_EXPONENT,       40, 'R');\n      case 'E': index_++;     return Operator(OPERATOR_EXPONENT,       40, 'R');\n      default :               return Operator(OPERATOR_NULL,            0, 'L');\n    }\n  }\n\n  static T toInteger(char c) {\n    if (c >= '0' && c <= '9') return c -'0';\n    if (c >= 'a' && c <= 'f') return c -'a' + 0xA;\n    if (c >= 'A' && c <= 'F') return c -'A' + 0xA;\n    T noDigit = 0xF + 1;\n    return noDigit;\n  }\n\n  T parseDecimal() {\n    T value = 0;\n    for (T d; (d = toInteger(getCharacter())) <= 9; index_++)\n      value = value * 10 + d;\n    return value;\n  }\n\n  T parseHex() {\n    index_ = index_ + 2;\n    T value = 0;\n    for (T h; (h = toInteger(getCharacter())) <= 0xf; index_++)\n      value = value * 16 + h;\n    return value;\n  }\n\n  bool isHex() const {\n    if (index_ + 2 < expr_.size()) {\n      char x = expr_[index_ + 1];\n      char h = expr_[index_ + 2];\n      return (std::tolower(x) == 'x' && toInteger(h) <= 0xf);\n    }\n    return false;\n  }\n\n  /// Parse an integer value at the current expression index.\n  /// The unary `+', `-' and `~' operators and opening\n  /// parentheses `(' cause recursion.\n  ///\n  T parseValue() {\n    T val = 0;\n    eatSpaces();\n    switch (getCharacter()) {\n      case '0': if (isHex()) {\n                  val = parseHex();\n                  break;\n                }\n      case '1': case '2': case '3': case '4': case '5':\n      case '6': case '7': case '8': case '9':\n                val = parseDecimal();\n                break;\n      case '(': index_++;\n                val = parseExpr();\n                eatSpaces();\n                if (getCharacter() != ')') {\n                  if (!isEnd())\n                    unexpected();\n                  throw parser_error(expr_, \"Syntax error: `)' expected at end of expression\");\n                }\n                index_++; break;\n      case '~': index_++; val = ~parseValue(); break;\n      case '+': index_++; val =  parseValue(); break;\n      case '-': index_++; val =  parseValue() * static_cast<T>(-1);\n                break;\n      default : if (!isEnd())\n                  unexpected();\n                throw parser_error(expr_, \"Syntax error: value expected at end of expression\");\n    }\n    return val;\n  }\n\n  /// Parse all operations of the current parenthesis\n  /// level and the levels above, when done\n  /// return the result (value).\n  ///\n  T parseExpr() {\n    stack_.push(OperatorValue(Operator(OPERATOR_NULL, 0, 'L'), 0));\n    // first parse value on the left\n    T value = parseValue();\n\n    while (!stack_.empty()) {\n      // parse an operator (+, -, *, ...)\n      Operator op(parseOp());\n      while (op.precedence  < stack_.top().getPrecedence() || (\n             op.precedence == stack_.top().getPrecedence() &&\n             op.associativity == 'L')) {\n        // end reached\n        if (stack_.top().isNull()) {\n          stack_.pop();\n          return value;\n        }\n        // do the calculation (\"reduce\"), producing a new value\n        value = calculate(stack_.top().value, value, stack_.top().op);\n        stack_.pop();\n      }\n\n      // store on stack_ and continue parsing (\"shift\")\n      stack_.push(OperatorValue(op, value));\n      // parse value on the right\n      value = parseValue();\n    }\n    return 0;\n  }\n};\n\n#endif\n"]],"start1":0,"start2":0,"length1":0,"length2":12586}]],"length":12586,"saved":false}
